# 추상 클래스(Abstract Class)
## 추상 클래스
1. 추상 매서드가 하나라도 포함되면 해당 클래스는 추상 클래스로 정의돼야 함
2. 추상 클래스는 객체를 생성 할 수 없음 -> 일반 클래스와의 차이
3. 그 외의 다른 특징은 일반 클래스와 동일함
4. 상속을 전제로 하는 클래스

- 추상 매서드 : 선언만 있고 구현은 없는 매서드
- 추상 클래스 : 추상 매서드를 하나 이상 가지고 있는 클래스

```java
public void showInfo() {
    System.out.println("안녕하세요");     //일반 매서드
}

public abstract void showInfo();        //추상 매서드
                                        //구현부{}는 자식 클래스에서 적용
```

## 추상 클래스의 장점
- 코드의 재사용성을 높이고 설계를 보다 명확하게 할 수 있도록 도와준다

## 추상 클래스의 목적
1. 공통된 기능 제공 - 여러 클래스에서 공통적으로 사용하는 기능을 추상 클래스에서 정의 가능
2. 구체적인 구현 강제 - 추상 매서드를 통해 자식 클래스가 반드시 특정 매서드를 구현하도록 강제 가능
3. 코드의 재사용성 - 중복되는 코드를 줄이고 유지 보수성 ↑

## super 키워드 - 부모 클래스의 field 및 매서드에 접근하기 위해서 사용
1. super() -> 자식 클래스에서 부모 클래스로 생성자를 호출 할 때 사용
2. super.asdf() -> 자식 클래스에서 부모 클래스로 매서드를 호출 할 때 사용


# 인터페이스(Interface)
- Java 에서 클래스가 구현해야 하는 매서드들의 집합을 정의하는 일종의 규약(protocol)
- 인터페이스는 매서드의 시그니처(매서드명, 리턴 타입, 매개변수 목록)만들 포함하며, 매서드의 실제 구현은 포함하지 않음   
-> 추상 매서드와 유사
- 다중 상속을 지원 -> 이를 통해 클래스가 여러 인터페이스를 구현 할 수 있음

## 특징
1. 추상 매서드 : 인터페이스 내의 모든 매서드들은 기본적으로 추상 매서드
2. 상수 : 인터페이스 내에서 선언된 변수들은 모두 자동으로 public static final 상수로 취급됨
3. 다중 상속 : 클래스는 여러 인터페이스를 구현 할 수 있음

## 추상 클래스와의 공통점
- 모두 추상 매서드를 포함 할 수 있고, 이를 자식 클래스에서 구현해야만 한다.

## 추상 클래스와의 차이점
- 추상 클래스
  1. 부분 부현 허용 - 추상 클래스는 추상 매서드 뿐만 아니라 일반 매서드도 포함 할 수 있다.
  2. 상태 저장 가능 - 추상 클래스는 변수를 가질 수 있다
  3. 단일 상속 - 클래스는 하나의 추상 클래스만 상속 받을 수 있다.
  4. 생성자 - 추상 클래스는 생성자를 가질 수 있다.
  5. 다양한 접근 지정자 - 추상 클래스의 매서드와 변수는 다양한 접근 지정자를 가질 수 있다.
- 인터페이스
  1. 완전한 추상화 - 인터페이스는 기본적으로 모든 매서드가 추상 매서드(Java8 이후에 default / static 등 접근 지정자와 키워드를 사용 가능함)
  2. 인터페이스는 인스턴스 변수(필드 중 객체마다 값이 다른 변수)를 가질 수 없고 상수만 선언 가능   
     -> 상수는 선언과 동시에 초기화 되어야 하며 이후 값을 바꿀수 없음
  3. 다중 상속 - 클래스는 여러 인터페이스를 구현 할 수 있다
  4. 생성자 없음 - 인터페이스는 생성자를 가질 수 없다.   
  -> 필드에서 객체마다 다른 값을 지닐 수 없기 때문에 생성자를 정의할 필요도 없음
  5. 자동 public - 인터에피스의 매서드들은 자동으로 public 이며 매서드 선언에 접근 지정자를 명시 할 필요없음(Java8 이후 default / static 매서드가 생기긴 함)

------------------------------------
1. interface Up의 void onUp() -> String onUp()
2. abstract class 인 Button 에서 구현 했을 때
```java
public abstract class Button implements Up, Down, Press{
    @Override
    public String onUp() {
        return "올립니다.";
    };
}
```
```java
public class ChannelUpButton extends Button{
    @Override
    public String onUp() {
        return "채널을 계속 " + super.onUp();
    }
}
```
```java
public class TvRemoteController {
    public void channelUp() {
        System.out.print("TV의 ");
        channelUpButton.onUp();
    }
}
```
Main 에서 실행해 보니 "TV의" 까지만 뜨고 "채널을 계속 올립니다" 가 안뜸   
->System.out.print로 값을 받아서 출력까지 해 주어야 함

# 참조 자료형 캐스팀(Reference Type Casting)
## 정의
- Java 에서 자료형은 크게 두가지로 구분
  - 기본 자료형(Primitive Type) - int, double, char ...etc
  - 참조 자료형(Reference Type) - 객체를 참조하는 변수로 클래스나 인터페이스로 생성된 객체

### 참조 자료형 캐스팅이란?    
    객체의 자료형을 변환하는 작업
-----------------
- 여태까지의 객체 생성 방식
```java
Name name = new Name();
```
- 참조 자료형 캐스팅의 의미를 고려했을 때의 객체 생성 방식
```java
Name name = new NickName();
```

## 캐스팅의 종류
1. 업캐스팅 - 하위 클래스 타입의 객체를 상위 클래스 타입으로 변환
2. 다운캐스팅 - 상위 클래스 타입의 객체를 하위 클래스 타입으로 변환
### 추가적으로 기억 해야 할 사항 
#### 연산자(Operator) instanceof
  - 1 + 1 == 2 에서 +가 연산자에 해당하는 개념인데
  - 객체면 instanceof 클래스명 -> return true / false
    - walk instanceof Human -> true

### 업캐스팅
- 암시적(Implicit)으로 이루어짐 -> 알아서 바뀜 하지만 언제 바뀌었는지는 개발자가 알아야 함
### 다운캐스팅
- 명시적(Explicit)으로 이루어짐 -> 반드시 개발자가 적절한 장소와 시간대에 사용해야 함
#### 업캐스팅과 다운캐스팅의 활용
- 캐스팅은 주로 다형성(Polymorphism)을 구현 할 때 사용
- 상위 클래스 타입으로 객체를 처리하면서도 동시에 하위 클래스의 고유 기능을 사용 가능

### 캐스팅의 장단점
- 장점
  - 코드 유연성 - 업캐스팅을 통한 다양한 객체를 하나의 상위 클래스 타입으로 관리 가능
  - 다형성 구현 - 매서드 오버라이딩과 함께 사용되면 코드의 재사용성 향상
- 단점
  - 다운캐스팅의 위험성 - 잘못 다운캐스팅을 하게 될 위험성이 있음   
    #### ex) 상위 클래스 A와 하위 클래스 B,C가 있다고 할 때 B의 객체인 b를 A로 업캐스팅을 해서 공통 매서드를 실행시킨 후에, C자료형으로 다운캐스팅을 하게 되면 오류 발생
    - 복잡성 증가 - 코드 가독성이 떨어질 수 있음 A로 바꿨다가 B로 내렸다가 A로 올렸다가 C로 잘못 다운캐스팅하면 안되니까 보험용코드 작성 등 복잡성 증가    
      특시 업캐스팅의 경우 암시적으로 일어나니까 알아서 상위 클래스로 바뀌었는데 언제 바뀌었는지 모르는 상태로 다운 캐스팅을 진행하려고 하면 오류 발생하고 어디서 잘못됐는지 모르는 상황이 발생
    - 이런 문제를 해결하기 위한 instanceof
```java
public static void main(String[] args) {
  System.out.println(objectA instanceof ClassA);
}
```
- return 값이 boolean 이므로 if 조건문과 사용되는 일이 많음